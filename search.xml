<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React父组件和子组件解耦方案</title>
    <url>/2019/03/24/React%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>业务中经常会遇到抽离组件的情况，那么父组件和子组件之间该怎么解耦呢？</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>比如实现一个 List 组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Item = <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.list.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">text</span>=<span class="string">&#123;x&#125;</span> /&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我们封装父组件经常会直接用到这种方法，但是如果该父组件是一个公共组件，那么当我们在外部引用它时，它对于我们而言其实是一个黑盒。父组件和子组件通过 list 牢牢的耦和在了一起。</p>
<span id="more"></span>

<h2 id="解耦方案"><a href="#解耦方案" class="headerlink" title="解耦方案"></a>解耦方案</h2><h3 id="一、使用-render-props"><a href="#一、使用-render-props" class="headerlink" title="一、使用 render props"></a>一、使用 render props</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children(<span class="built_in">this</span>.state.list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- jsx</span><br><span class="line"></span><br><span class="line">&lt;List&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">list</span>) =&gt;</span> list.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">text</span>=<span class="string">&#123;x&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">&lt;/List&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，通过 render props 的设计实现了父组件和子组件之间的解耦。</p>
<h3 id="二、Compound-Component"><a href="#二、Compound-Component" class="headerlink" title="二、Compound Component"></a>二、Compound Component</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      React.Children.map(</span><br><span class="line">        <span class="built_in">this</span>.props.children,</span><br><span class="line">        <span class="function">(<span class="params">child, i</span>) =&gt;</span> React.cloneElement(child, &#123;</span><br><span class="line">          <span class="attr">text</span>: state.list[i]</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--jsx</span><br><span class="line"></span><br><span class="line">&lt;List&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Item</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Item</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Item</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Item</span> /&gt;</span></span></span><br><span class="line">&lt;/List&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 compound component 也能实现父子组件解耦，只是在这里可能不是那么完美。其实 compound component 的应用远不止如此，读者可以自行挖掘。😃</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>compound component 和 render props 均实现了父子组件的解耦，并且父组件对于使用者来说也不再是一个黑盒。</p>
<h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>将父子组件解耦后，父子组件之间只需要接口达成一致便能完成使用。此时若将单元测试覆盖于测试用例，具体又有什么便利之处呢？👾</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>组件设计</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo发布文章流程记录</title>
    <url>/2018/11/09/hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>新建文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;title&quot;</span><br></pre></td></tr></table></figure>

<p>生成静态网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>本地预览</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>同步至 github 服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Create-react-app中使用装饰器语法</title>
    <url>/2019/03/01/Create-react-app%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>想要在 create-react-app 中使用 mobx，因为装饰器模式看起来简单，所以想让 create-react-app 支持装饰器语法。</p>
<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create-react-app test-decorator</span><br><span class="line">npm install -s mobx-react mobx</span><br></pre></td></tr></table></figure>

<p>安装完毕后，若直接在 class 中使用 mobx 的@observer 语法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;@observer&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br></pre></td></tr></table></figure>

<p>此时会报编译错误</p>
<span id="more"></span>

<p><img src="1551331520473.png" alt="1551331520473"></p>
<p>所以需要使用 babel 让编译时能支持装饰器语法。</p>
<blockquote>
<p>ps：create-react-app 可以使用其他方式支持装饰器语法，这里只提供一种简单粗暴的形式-弹出。</p>
</blockquote>
<h3 id="弹出-create-react-app-的项目"><a href="#弹出-create-react-app-的项目" class="headerlink" title="弹出 create-react-app 的项目"></a>弹出 create-react-app 的项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure>

<p>发现出了点小意外:</p>
<p>mobx 不应该先装，<code>eject得在工作区没有改动时启用，不然会弹出失败。</code></p>
<p>于是先提交工作区的改动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -a -m &quot;init&quot;</span><br></pre></td></tr></table></figure>

<p>然后再次 eject</p>
<h3 id="安装-babel-plugin-proposal-decorators"><a href="#安装-babel-plugin-proposal-decorators" class="headerlink" title="安装@babel/plugin-proposal-decorators"></a>安装<code>@babel/plugin-proposal-decorators</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-proposal-decorators</span><br></pre></td></tr></table></figure>

<p>在<code>package.json</code>中加上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行报错</p>
<p><img src="1551335060987.png" alt="1551335060987"></p>
<p>加上<code>decoratorsBeforeExport</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">&quot;decoratorsBeforeExport&quot;</span>: <span class="literal">true</span> &#125;],</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<p><img src="1551335316388.png" alt="1551335316388"></p>
<p>改成</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, &#123; <span class="attr">&quot;loose&quot;</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功!!!</p>
<p>猜测和我的下面的写法有关，装饰器挂在头部怪怪的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a</span><br><span class="line">class B</span><br></pre></td></tr></table></figure>

<p>好像大佬们认为下面这样更好一点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> @a <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Babel</tag>
        <tag>Mobx</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>mobx初探</title>
    <url>/2019/04/23/mobx%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文是笔者在看了 frontendmaster 的状态管理课程之后，对 mobx 进行的初步学习的总结。</p>
<h2 id="二、Mobx-简介"><a href="#二、Mobx-简介" class="headerlink" title="二、Mobx 简介"></a>二、Mobx 简介</h2><p>mobx 是社区内使用的较为常见的一种状态管理库，mobx 官网称其</p>
<blockquote>
<p>通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展</p>
</blockquote>
<p>mobx 主要有以下几个核心特性：</p>
<ul>
<li>Observable State（可观察状态）</li>
<li>Computed Values（计算属性）</li>
<li>Reactions（反应，完成页面渲染、日志打印）</li>
<li>Actions（动作）</li>
</ul>
<p>以下介绍将结合部分 mobx 代码，代码地址： <a href="https://jsbin.com/demelo/19/edit?html,js,console,output">示例代码</a></p>
<span id="more"></span>

<p>详细代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;console&quot;</span> /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">const</span> &#123; computed, observable, autorun &#125; = mobx;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @observable firstName;</span><br><span class="line">  @observable secondName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstName, secondName</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.secondName = secondName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @computed <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.secondName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wdz = <span class="keyword">new</span> Person(<span class="string">&#x27;Demian&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> greet = observable.box(<span class="string">&#x27;good morning! &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;console&#x27;</span>).innerText = greet + wdz.fullName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 动态更新dom内容</span></span><br><span class="line">autorun(render);</span><br></pre></td></tr></table></figure>

<p>此时网页 ui 为：</p>
<p><img src="1.png" alt="1"></p>
<h3 id="1-Computed-Values"><a href="#1-Computed-Values" class="headerlink" title="1.Computed Values"></a>1.Computed Values</h3><p>首先介绍一下计算属性。在上述代码中 fullName 就是计算属性。相信用过 vue 的对这个很熟悉。当我们在命令行手动修改 wdz 的 firstName 时，wdz 的 fullName 会自动更新</p>
<p><img src="2.png" alt="2"></p>
<p>此时网页 ui 也发生了实时的变化：</p>
<p><img src="3.png" alt="3"></p>
<p>可见，computed 属性可以响应 observable 属性的变化。</p>
<p>值得一提的是，在 react 的 render 函数中，如果存在很多 props 的计算的话，可以使用 get 语法的形式将这部分逻辑抽离：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.props.firstName + <span class="built_in">this</span>.props.secondName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.fullName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 fullName 和可计算属性类似，依据传入的 props 属性动态变化。</p>
<h3 id="2-Observable-State"><a href="#2-Observable-State" class="headerlink" title="2.Observable State"></a>2.Observable State</h3><p>通过在类属性前加上@observable，为该属性添加了可观察功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @observable firstName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstName</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用装饰器语法很简洁的使得 name 拥有了可观察的功能。</p>
<p>那么 Observable 有什么作用呢？</p>
<p>见以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = observable.box(<span class="string">&#x27;good morning! &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们为 greet 返回一个 observable 包装过的值，首先我们试着直接改变 greet 的值</p>
<p><img src="4.png" alt="4"></p>
<p>但是，此时网页 ui 没有实时变化：</p>
<p><img src="5.png" alt="5"></p>
<p>可见，原始类型在包装过之后，<strong>直接改变引用值不能触发页面动态更新</strong>，感兴趣的读者可以点击上面的链接打印出 greet 的属性，就能很直观的认识到 observable 的作用。</p>
<p>以下是简化版的 observable：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的observable</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>, <span class="built_in">this</span>.value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>, newValue);</span><br><span class="line">      <span class="comment">// 向全局通知该数据更新</span></span><br><span class="line">      report(<span class="built_in">this</span>.value, newValue);</span><br><span class="line">      <span class="built_in">this</span>.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive代码</span></span><br><span class="line">eventEmitter.on(<span class="string">&#x27;report&#x27;</span>, <span class="function">(<span class="params">oldValue, newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(oldValue, <span class="string">&#x27;===&gt;&#x27;</span>, newValue);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知给全局</span></span><br><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">oldValue, newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  eventEmitter.emit(<span class="string">&#x27;report&#x27;</span>, oldValue, newValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要是使用 value 值存储原始类型，使用 get 获取 value 值，使用 set 更新 value 值。值得注意的是，在更新数据以前，set 方法会根据一定的配置，选择是否向全局发送更新事件，相应的一些 computed 的属性会接收到该事件。</p>
<h3 id="3-Reactions"><a href="#3-Reactions" class="headerlink" title="3.Reactions"></a>3.Reactions</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;console&#x27;</span>).innerText = greet + wdz.fullName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 动态更新dom内容</span></span><br><span class="line">autorun(render);</span><br></pre></td></tr></table></figure>

<p>当 observable 数据变化后，页面会自动更新 ui。</p>
<h2 id="三、mobx-实战-实现一个-todoList"><a href="#三、mobx-实战-实现一个-todoList" class="headerlink" title="三、mobx 实战-实现一个 todoList"></a>三、mobx 实战-实现一个 todoList</h2><p>注：由于 create-react-app 创建的项目默认不能使用装饰器语法，所以笔者暴力的 eject 并安装了相应的 babel 配置。</p>
<p>以下是 todoList 的项目结构：</p>
<p><img src="6.png" alt="6"></p>
<p>最终实现效果：</p>
<p><img src="7.png" alt="7"></p>
<p>项目地址：<a href="https://github.com/Demian1996/todo/tree/mobx-todo">todolist</a></p>
<p>当我们使用 mobx 维护状态时，store 不像 redux 那样是全局唯一的，我们可以细粒度地维护一个个数据模型。在中小型的项目中，mobx 的 store 轻便简洁，使用起来很顺滑。</p>
<p>项目中用到的 mobx 特性：</p>
<h3 id="1-observable"><a href="#1-observable" class="headerlink" title="1.observable"></a>1.observable</h3><p>主要维护 todolist 的基本状态：待办列表 todolist、新建待办的内容 itemContent 和当前筛选类型 filterType</p>
<p><img src="8.png" alt="8"></p>
<h3 id="2-computed"><a href="#2-computed" class="headerlink" title="2.computed"></a>2.computed</h3><p>根据当前筛选器的类型，返回对应的 todoList。</p>
<p><img src="9.png" alt="9"></p>
<h3 id="3-reactions"><a href="#3-reactions" class="headerlink" title="3.reactions"></a>3.reactions</h3><p>筛选器状态变化后，响应式地打印出当前筛选器的状态。</p>
<p><img src="10.png" alt="10"></p>
<h3 id="4-actions"><a href="#4-actions" class="headerlink" title="4.actions"></a>4.actions</h3><p>点击筛选器后的状态切换和异步事件。这里需要使用 runInAction 包装异步函数，这样才可以完成响应式的更新数据。</p>
<p><img src="11.png" alt="11"></p>
<h2 id="四、Mobx-vs-Redux"><a href="#四、Mobx-vs-Redux" class="headerlink" title="四、Mobx vs Redux"></a>四、Mobx vs Redux</h2><p>两者都是优秀的状态管理工具，都可以帮助开发者完成业务开发。所以抛开业务场景谈论工具优劣是无意义的，笔者这里只是简单列出两者的区别。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><img src="12.png" alt="12"></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><img src="13.png" alt="13"></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>笔者只是介绍了 mobx 的冰山一角，其作为一种响应式的状态管理库，在中小型项目中有着高效率的表现。响应式的写法、细粒度的 store 管理都体现了 mobx 的灵活性。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>状态管理</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>react中减少render臃肿的方法</title>
    <url>/2019/03/07/react%E4%B8%AD%E5%87%8F%E5%B0%91render%E8%87%83%E8%82%BF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近看了mobx的相关知识，对computed属性十分喜欢。</p>
<p>想起在日常的项目开发中，react经常需要在render函数的开始部分进行一些props属性的计算，再将计算值用于渲染。一般会有以下画面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, secondName &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> fullName = firstName + secondName;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;fullName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>当业务逻辑复杂时可能会造成render函数十分的臃肿。也许我们会进行这样的优化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getFullName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, secondName &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> firstName + secondName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.getFullName()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们实质上寻求的是一种computed的属性，将其封装成函数只是一种曲线救国的手段。<br>直到我在看frontend master的过程中，才发现原来可以使用class的get属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, secondName &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> firstName + secondName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.fullName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>使用get属性实现computed的功能可以减少render函数的臃肿。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Github Pages上部署create-react-app项目</title>
    <url>/2020/06/17/%E5%A6%82%E4%BD%95%E5%9C%A8Github-Pages%E4%B8%8A%E9%83%A8%E7%BD%B2create-react-app%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>笔者经常会用 create-react-app 做些 demo 项目。其中某些打算维护的项目，笔者会将其放到 github 上。但是此时的问题往往是，README 不能够很好的阐述项目的全貌，此时就需要将项目部署到线上，达到在线预览的效果。而 Github Pages 服务就可以很好的满足这个效果。</p>
<span id="more"></span>

<h2 id="步骤介绍"><a href="#步骤介绍" class="headerlink" title="步骤介绍"></a>步骤介绍</h2><h3 id="一、项目初始化"><a href="#一、项目初始化" class="headerlink" title="一、项目初始化"></a>一、项目初始化</h3><p>创建项目:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx create-react-app demo</span><br></pre></td></tr></table></figure>

<p>然后在 package.json 中配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span>: <span class="string">&quot;gh-pages -d build&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 homepage 是为了后续打包时生成的路径为相对路径。<br>配置 deploy 是为了打完包后将所有静态文件部署到 github 的 gh-pages 分支上。</p>
<blockquote>
<p>Github Pages 默认只支持 master、gh-pages 两个分支和 master/docs 目录。</p>
</blockquote>
<h3 id="二、构建本地项目"><a href="#二、构建本地项目" class="headerlink" title="二、构建本地项目"></a>二、构建本地项目</h3><p>本文中默认用的构建脚手架是 create-react-app，生成的 package.json 中自带了构建命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>执行后，项目中会生成 build 目录</p>
<h3 id="三、安装-gh-pages-依赖"><a href="#三、安装-gh-pages-依赖" class="headerlink" title="三、安装 gh-pages 依赖"></a>三、安装 gh-pages 依赖</h3><blockquote>
<p>gh-pages: 默认会发布文件到 github 的 gh-pages 分支</p>
</blockquote>
<p>安装依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install gh-pages --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="四、部署"><a href="#四、部署" class="headerlink" title="四、部署"></a>四、部署</h3><p>运行命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure>

<p>完成后，github 上会生成 gh-pages 分支，该分支下包含 build 目录中所有文件</p>
<p>此时打开 github，进入到具体项目中，具体如图所示</p>
<p><img src="1.png" alt="1"></p>
<p><img src="2.png" alt="2"></p>
<p>然后，点击 settings，在 Github Pages 标题下，将 source 分支设置为 gh-pages。<br>如图所示</p>
<p><img src="3.png" alt="3"></p>
<p>然后访问 {username}.github.io/{项目名}，就可以在线预览项目了。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>封装useModal复用公共弹窗组件</title>
    <url>/2020/08/09/%E5%B0%81%E8%A3%85useModal%E5%A4%8D%E7%94%A8%E5%85%AC%E5%85%B1%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在常规的业务开发中，经常会用到 Modal 组件。当笔者在开发实际项目时，业务需求要求我在同一个页面分别使用 2-3 种弹窗。理论来说此时只需要使用一个 Modal 组件，定制不同内容即可。但是痛苦常常来源于生活，由于团队人员变动、公共组件管理不够规范、重复造轮子等各种原因，我们往往需要接入各种不同种类的弹窗组件，比如在下面的代码中，我使用的 ExitModal 和 DeleteModal 就出自不同人之手：</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isShowExitModal, setIsShowExitModal] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isShowDeleteModal, setIsShowDeleteModal] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsShowExitModal(true)&#125;&gt;显示退出弹窗<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsShowDeleteModal(true)&#125;&gt;显示删除弹窗<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ExitModal</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">visible</span>=<span class="string">&#123;isShowExitModal&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onOk</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">          console.log(&#x27;成功退出&#x27;);</span></span><br><span class="line"><span class="xml">          setIsShowExitModal(false);</span></span><br><span class="line"><span class="xml">        &#125;&#125;</span></span><br><span class="line"><span class="xml">        onCancel=&#123;() =&gt; setIsShowExitModal(false)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">DeleteModal</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">visible</span>=<span class="string">&#123;isShowDeleteModal&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onOk</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;成功删除&#x27;)&#125;</span></span><br><span class="line"><span class="xml">        onCancel=&#123;() =&gt; setIsShowDeleteModal(false)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该组件的状态依赖如下所示：</p>
<p><img src="1.png" alt="1"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可以看到，在现有场景下，我们封装业务组件如果以这种模式处理，往往会面临以下问题：</p>
<ul>
<li>业务组件需要维护和直接依赖 Modal 组件的显隐状态，Modal 组件越多，冗余的 ui 状态越多</li>
<li>如果 Modal 组件在封装时没有使用 createPortal 的 API，Modal 组件就会挂载到业务组件的真实 dom 中，影响业务组件的 dom 树</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>首先我们期望的是在优化之后能够保证业务组件和 Modal 组件的状态脱钩，业务组件仅仅需要调用第三方提供的 show 方法调起弹窗，后续的操作都交给第三方处理。其次，我们期望在优化之后，无论 Modal 组件之前是怎么设计的，业务方调用时都会将其挂载到 body 下，不影响自身的 dom 结构。</p>
<p>因此，笔者封装了 useModal 这个 hook，接受 Modal 组件，返回统一的 Modal 代理。由代理解决上面的两个问题。具体使用如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> exitModal = useModal(ExitModal);</span><br><span class="line">  <span class="keyword">const</span> deleteModal = useModal(DeleteModal);</span><br><span class="line">  <span class="keyword">const</span> onShowExitModal = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    exitModal.show(&#123;</span><br><span class="line">      <span class="attr">onOk</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;退出成功&#x27;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [exitModal]);</span><br><span class="line">  <span class="keyword">const</span> onShowDeleteModal = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    deleteModal.show(&#123;</span><br><span class="line">      <span class="attr">onOk</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [deleteModal]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;onShowExitModal&#125;</span>&gt;</span>显示退出弹窗<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;onShowDeleteModal&#125;</span>&gt;</span>显示删除弹窗<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，业务组件只需要依赖不同 modal 实例的代理，调用代理的 show 方法调起弹窗，不需要手动修改 visible 状态和在 renderTree 中插入 Modal 组件。</p>
<h2 id="UseModal-详解"><a href="#UseModal-详解" class="headerlink" title="UseModal 详解"></a>UseModal 详解</h2><p>使用 useModal 后的 uml 图如下所示：</p>
<p><img src="2.png" alt="2"></p>
<p>useModal 接受实现了 Modal 接口的 React 组件，然后返回一个代理，该代理提供了 show 和 destroy 方法。窗口的 ui 状态和组件挂载逻辑交由代理控制，业务组件只需要知道代理的接口，即可实现窗口管理。</p>
<p>下面介绍一下 useModal 实现 show 和 destroy 的基本原理：</p>
<p>useModal 会维护具体的窗口实例的 visible 状态和真实的 Modal 组件，在业务调用 show 方法时，useModal 会调用 ReactDOM 的 render 方法将 Modal 组件挂载到 body 的 dom 下，在业务调用 destroy 方法是 ReactDOM 的 unmountComponentAtNode 方法卸载状态。<br>具体逻辑如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unmount = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = ReactDOM.unmountComponentAtNode(mountNode);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; mountNode.parentNode) &#123;</span><br><span class="line">    mountNode.parentNode.removeChild(mountNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [mountNode]);</span><br><span class="line"><span class="keyword">const</span> render = useCallback(</span><br><span class="line">  <span class="function">(<span class="params">modalProps: IModalProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(mountNode);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Modal</span> &#123;<span class="attr">...modalProps</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span>, mountNode);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  [mountNode]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>当前的 useModal 很好的实现了状态解耦，但是可以看到它给所有 Modal 组件增加了一层约束，即所有弹窗组件都要满足 Modal 这一接口。</p>
<p>实际业务中，可能会遇到 Modal 组件不符合这一接口的，此时我们可以通过进一步实现 ModalAdapter 等方式解决问题。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>组件设计</tag>
        <tag>React Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>ramda开发命令行工具生成多语言字典</title>
    <url>/2019/11/29/ramda%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<blockquote>
<p>github 地址：<a href="https://github.com/Demian1996/translate">https://github.com/Demian1996/translate</a></p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>命令行工具 translate，给定中文字典，生成 google 翻译后的多语言文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">translate -f zh-CN.json -l en/ja</span><br></pre></td></tr></table></figure>

<p>通过该命令生成多语言文件</p>
<span id="more"></span>
<h2 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h2><ul>
<li>命令行工具<code>commander</code></li>
<li>请求库<code>request</code></li>
<li>函数库<code>ramda</code></li>
</ul>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h4 id="目录总览"><a href="#目录总览" class="headerlink" title="目录总览"></a>目录总览</h4><p><img src="1.png" alt="1"></p>
<p>bin 是业务逻辑处理文件</p>
<p>package.json 配置依赖</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>首先在<code>package.json</code>的文件中配置<code>bin</code>，指定文件路径和对应的命令名:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;translate&quot;</span>: <span class="string">&quot;./bin/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 bin 文件夹下新建入口文件 index.js，在文件首行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure>

<p>这一行是指定使用 node 执行脚本文件</p>
<p>然后执行命令<code>npm link</code>，就可以全局使用 translate 命令了。</p>
<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>使用模块 Commander 解析命令行参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commander.option(<span class="string">&#x27;-f --file &lt;filename&gt;&#x27;</span>, <span class="string">&#x27;translate file&#x27;</span>, callback);</span><br><span class="line">commander.option(<span class="string">&#x27;-l --languages [languages]&#x27;</span>, <span class="string">&#x27;languages&#x27;</span>, <span class="string">&#x27;en&#x27;</span>);</span><br><span class="line">commander.parse(process.argv);</span><br></pre></td></tr></table></figure>

<p>通过<code>-f</code>指定中文字典文件，通过<code>-l</code>指定目标语言，默认翻译为英文。<code>callback</code>主要是判断文件是否存在若不存在则返回 null，存在则返回 json 对象。后续可以通过 commander.file 获取 json 对象。</p>
<h4 id="流程处理"><a href="#流程处理" class="headerlink" title="流程处理"></a>流程处理</h4><p>业务逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generateDictionary = R.pipe(getLanguageArray, fetchTranslateApi, mapTranslation, generateFile);</span><br><span class="line">generateDictionary();</span><br></pre></td></tr></table></figure>

<p>即获取目标语言数组-&gt;爬取 google 翻译 api-&gt;从返回值中筛选出翻译值-&gt;生成目标语言的 json 文件。</p>
<p>详细流程见源码</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>Ramda</tag>
        <tag>函数式编程</tag>
        <tag>命令行工具</tag>
      </tags>
  </entry>
  <entry>
    <title>配置项目ts和hook的eslint约束</title>
    <url>/2020/08/14/%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AEts%E5%92%8Chook%E7%9A%84eslint%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>teacher-web 端之前用的是 tslint，考虑到 typescript 团队已经停止维护 tslint，且 Eslint 规范更多，所以将教师空间中的 ts 代码检查整合到 Eslint 中。整理此份文档，方便后续参照。</p>
<p>鉴于项目中普遍用的均为 alloyTeam 的配置规范，所以最终决定 js 和 ts 文件的 eslint 配置均统一使用 alloyTeam 的配置规范。详细地址见<a href="https://github.com/AlloyTeam/eslint-config-alloy">eslint-config-alloy</a></p>
<span id="more"></span>

<h2 id="第一步：安装-更新-Vscode-插件-Eslint"><a href="#第一步：安装-更新-Vscode-插件-Eslint" class="headerlink" title="第一步：安装/更新 Vscode 插件 Eslint"></a>第一步：安装/更新 Vscode 插件 Eslint</h2><p>vscode 中更新 Eslint 插件到最新版，保证对 typescript-eslint 的支持。</p>
<p><img src="1.png" alt="1"></p>
<h2 id="第二步：安装-Eslint-config-alloy"><a href="#第二步：安装-Eslint-config-alloy" class="headerlink" title="第二步：安装 Eslint-config-alloy"></a>第二步：安装 Eslint-config-alloy</h2><p>AlloyTeam ESLint：是一套先进的适用于 React/Vue/Typescript 项目的 ESLint 配置规范，而且也是配置个性化 ESLint 规则的最佳参考。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-config-alloy</span><br></pre></td></tr></table></figure>

<p>安装完毕后，在.eslintrc.js 文件中新增配置如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;alloy&#x27;</span>, <span class="string">&#x27;alloy/react&#x27;</span>, <span class="string">&#x27;alloy/typescript&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时项目已经支持对 ts 的 eslint 限制， 可以通过新建一个 index.tsx，在其中新建变量 var，此时 eslint 会进行报错：</p>
<p><img src="2.png" alt="2"></p>
<blockquote>
<p>ps: 如果装完后，vscode 没有成功给出提示。先打开 vscode 命令行，在“终端”中选择 Eslint，查看具体错误。如果是报找不到包的错误，很可能是之前安装过上面的某个包，版本和现在安装的其他包不兼容。可以试试先将上面的所有包全部 uninstall，再重新 install。</p>
</blockquote>
<h2 id="第三步：安装-hook-规范"><a href="#第三步：安装-hook-规范" class="headerlink" title="第三步：安装 hook 规范"></a>第三步：安装 hook 规范</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint-plugin-react-hooks</span><br></pre></td></tr></table></figure>

<p>安装完毕后，在.eslintrc.js 文件中新增</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extends</span>: [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">&#x27;plugin:react-hooks/recommended&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里我们使用的是 plugin 提供的推荐配置，想要自定义配置可自行参照官方文档，在 rules 中进行配置。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>Eslint</tag>
        <tag>Typescript</tag>
        <tag>Alloy</tag>
      </tags>
  </entry>
</search>
